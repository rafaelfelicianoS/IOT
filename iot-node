#!/usr/bin/env python3
"""
CLI para controlar o IoT Node Device.

Comandos dispon√≠veis:
  start         - Inicia o Node
  interactive   - Inicia o Node com CLI interativo
  status        - Verifica status do Node
  logs          - Mostra logs do Node
  send          - Envia mensagem para o Sink

Exemplos:
  ./iot-node start
  ./iot-node interactive
  ./iot-node start --adapter 1
  ./iot-node start --cert-index 2
  ./iot-node logs --tail 50
  ./iot-node logs --follow
  ./iot-node send "Hello Sink"
"""

import sys
import subprocess
import argparse
from pathlib import Path

# Diret√≥rio base do projeto
BASE_DIR = Path(__file__).parent.absolute()
NODE_SCRIPT = BASE_DIR / "node" / "iot_node.py"
INTERACTIVE_NODE_SCRIPT = BASE_DIR / "node" / "interactive_node.py"
LOG_FILE = BASE_DIR / "logs" / "iot-network.log"

# Adicionar diret√≥rio base ao PYTHONPATH
sys.path.insert(0, str(BASE_DIR))

def cmd_start(args):
    """Inicia o Node Device."""
    print("="*60)
    print("  Iniciando IoT Node Device")
    print("="*60)
    print()

    # Auto-detectar certificados no diret√≥rio certs/
    certs_dir = BASE_DIR / "certs"

    # Procurar certificado do Node
    node_certs = list(certs_dir.glob("node_*_cert.pem"))
    node_keys = list(certs_dir.glob("node_*_key.pem"))
    ca_cert = certs_dir / "ca_certificate.pem"

    if not node_certs:
        print(f"‚ùå Nenhum certificado de Node encontrado em {certs_dir}/")
        print("   Esperado: node_*_cert.pem")
        return 1

    if not node_keys:
        print(f"‚ùå Nenhuma chave privada de Node encontrada em {certs_dir}/")
        print("   Esperado: node_*_key.pem")
        return 1

    if not ca_cert.exists():
        print(f"‚ùå Certificado CA n√£o encontrado: {ca_cert}")
        return 1

    # Usar o primeiro encontrado (ou permitir sele√ß√£o se m√∫ltiplos)
    if len(node_certs) > 1:
        print(f"\n‚ö†Ô∏è  M√∫ltiplos certificados Node encontrados:")
        for i, cert in enumerate(node_certs, 1):
            print(f"  {i}. {cert.name}")

        if args.cert_index is not None and 0 < args.cert_index <= len(node_certs):
            cert_to_use = node_certs[args.cert_index - 1]
            key_to_use = node_keys[args.cert_index - 1]
        else:
            print(f"\nUsando o primeiro: {node_certs[0].name}")
            print("(Use --cert-index N para escolher outro)")
            cert_to_use = node_certs[0]
            key_to_use = node_keys[0]
    else:
        cert_to_use = node_certs[0]
        key_to_use = node_keys[0]

    print(f"\n‚úÖ Certificados encontrados:")
    print(f"   Cert: {cert_to_use.name}")
    print(f"   Key:  {key_to_use.name}")
    print(f"   CA:   {ca_cert.name}")
    print()

    # Construir comando com os certificados
    cmd = [
        sys.executable, str(NODE_SCRIPT),
        "--cert", str(cert_to_use),
        "--key", str(key_to_use),
        "--ca-cert", str(ca_cert),
        "--adapter", str(args.adapter)
    ]

    try:
        subprocess.run(cmd, cwd=str(BASE_DIR))
    except KeyboardInterrupt:
        print("\n\n‚úÖ Node parado pelo utilizador")
        return 0
    except Exception as e:
        print(f"\n‚ùå Erro ao iniciar Node: {e}")
        return 1

    return 0

def cmd_interactive(args):
    """Inicia o Node Device com CLI interativo."""
    print("="*60)
    print("  Iniciando IoT Node Device (Interactive Mode)")
    print("="*60)
    print()

    # Auto-detectar certificados no diret√≥rio certs/
    certs_dir = BASE_DIR / "certs"

    # Procurar certificado do Node
    node_certs = list(certs_dir.glob("node_*_cert.pem"))
    node_keys = list(certs_dir.glob("node_*_key.pem"))
    ca_cert = certs_dir / "ca_certificate.pem"

    if not node_certs:
        print(f"‚ùå Nenhum certificado de Node encontrado em {certs_dir}/")
        print("   Esperado: node_*_cert.pem")
        return 1

    if not node_keys:
        print(f"‚ùå Nenhuma chave privada de Node encontrada em {certs_dir}/")
        print("   Esperado: node_*_key.pem")
        return 1

    if not ca_cert.exists():
        print(f"‚ùå Certificado CA n√£o encontrado: {ca_cert}")
        return 1

    # Usar o primeiro encontrado (ou permitir sele√ß√£o se m√∫ltiplos)
    if len(node_certs) > 1:
        print(f"\n‚ö†Ô∏è  M√∫ltiplos certificados Node encontrados:")
        for i, cert in enumerate(node_certs, 1):
            print(f"  {i}. {cert.name}")

        if args.cert_index is not None and 0 < args.cert_index <= len(node_certs):
            cert_to_use = node_certs[args.cert_index - 1]
            key_to_use = node_keys[args.cert_index - 1]
        else:
            print(f"\nUsando o primeiro: {node_certs[0].name}")
            print("(Use --cert-index N para escolher outro)")
            cert_to_use = node_certs[0]
            key_to_use = node_keys[0]
    else:
        cert_to_use = node_certs[0]
        key_to_use = node_keys[0]

    print(f"\n‚úÖ Certificados encontrados:")
    print(f"   Cert: {cert_to_use.name}")
    print(f"   Key:  {key_to_use.name}")
    print(f"   CA:   {ca_cert.name}")
    print()

    # Construir comando com os certificados
    cmd = [
        sys.executable, str(INTERACTIVE_NODE_SCRIPT),
        "--cert", str(cert_to_use),
        "--key", str(key_to_use),
        "--ca-cert", str(ca_cert),
        "--adapter", str(args.adapter)
    ]

    try:
        subprocess.run(cmd, cwd=str(BASE_DIR))
    except KeyboardInterrupt:
        print("\n\n‚úÖ Node parado pelo utilizador")
        return 0
    except Exception as e:
        print(f"\n‚ùå Erro ao iniciar Node: {e}")
        return 1

    return 0

def cmd_logs(args):
    """Mostra logs do Node."""
    if not LOG_FILE.exists():
        print(f"‚ùå Arquivo de log n√£o encontrado: {LOG_FILE}")
        return 1
    
    try:
        if args.follow:
            # Seguir logs em tempo real
            print("üìã Monitorando logs (Ctrl+C para parar)...")
            print()
            subprocess.run(["tail", "-f", str(LOG_FILE)])
        elif args.tail:
            # Mostrar √∫ltimas N linhas
            subprocess.run(["tail", "-n", str(args.tail), str(LOG_FILE)])
        elif args.grep:
            # Filtrar logs
            subprocess.run(["grep", "-i", "--color=auto", args.grep, str(LOG_FILE)])
        else:
            # Mostrar √∫ltimas 50 linhas por padr√£o
            subprocess.run(["tail", "-n", "50", str(LOG_FILE)])
    except KeyboardInterrupt:
        print("\n\n‚úÖ Monitoramento parado")
        return 0
    
    return 0

def cmd_status(args):
    """Verifica status do Node."""
    print("="*60)
    print("  Status do IoT Node Device")
    print("="*60)
    print()
    
    # Verificar se o log existe
    if LOG_FILE.exists():
        print(f"‚úÖ Log file: {LOG_FILE}")
        
        # Mostrar informa√ß√µes de conex√£o e autentica√ß√£o
        print("\nüìã Status da Conex√£o:")
        print("-"*60)
        subprocess.run([
            "grep", "-E",
            "Sink encontrado|Conectado ao Sink|Autentica√ß√£o|Session key|Node pronto|heartbeat",
            str(LOG_FILE)
        ], stderr=subprocess.DEVNULL)
        
        # Mostrar √∫ltimos heartbeats
        print("\nüíì √öltimos Heartbeats:")
        print("-"*60)
        subprocess.run([
            "grep", "Heartbeat recebido",
            str(LOG_FILE)
        ], stderr=subprocess.DEVNULL)
        subprocess.run(["tail", "-n", "5"])
    else:
        print(f"‚ö†Ô∏è  Nenhum log encontrado em {LOG_FILE}")
    
    return 0

def cmd_send(args):
    """Envia mensagem para o Sink (funcionalidade futura)."""
    print("‚ö†Ô∏è  Funcionalidade de envio de mensagens ainda n√£o implementada")
    print(f"    Mensagem a enviar: {args.message}")
    return 1

def main():
    parser = argparse.ArgumentParser(
        description="CLI para controlar o IoT Node Device",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Exemplos de uso:
  %(prog)s start                        Inicia o Node (adapter hci0)
  %(prog)s interactive                  Inicia Node com CLI interativo
  %(prog)s start --adapter 1            Inicia no adaptador hci1
  %(prog)s interactive --adapter 1      CLI interativo no adaptador hci1
  %(prog)s start --cert-index 2         Usa 2¬∫ certificado (se m√∫ltiplos)
  %(prog)s logs                         Mostra √∫ltimos logs
  %(prog)s logs --tail 100              Mostra √∫ltimas 100 linhas
  %(prog)s logs --follow                Segue logs em tempo real
  %(prog)s logs --grep auth             Filtra logs por padr√£o
  %(prog)s status                       Verifica status do Node
  %(prog)s send "Hello"                 Envia mensagem ao Sink (futuro)
        """
    )
    
    subparsers = parser.add_subparsers(dest='command', help='Comando a executar')
    
    # Comando: start
    parser_start = subparsers.add_parser('start', help='Inicia o Node Device')
    parser_start.add_argument('--adapter', type=int, default=0,
                             help='√çndice do adaptador BLE (default: 0 = hci0)')
    parser_start.add_argument('--cert-index', type=int, metavar='N',
                             help='√çndice do certificado a usar (se m√∫ltiplos)')

    # Comando: interactive
    parser_interactive = subparsers.add_parser('interactive', help='Inicia Node com CLI interativo')
    parser_interactive.add_argument('--adapter', type=int, default=0,
                                   help='√çndice do adaptador BLE (default: 0 = hci0)')
    parser_interactive.add_argument('--cert-index', type=int, metavar='N',
                                   help='√çndice do certificado a usar (se m√∫ltiplos)')
    
    # Comando: logs
    parser_logs = subparsers.add_parser('logs', help='Mostra logs do Node')
    parser_logs.add_argument('--tail', type=int, metavar='N',
                            help='Mostra √∫ltimas N linhas')
    parser_logs.add_argument('--follow', '-f', action='store_true',
                            help='Segue logs em tempo real')
    parser_logs.add_argument('--grep', type=str, metavar='PATTERN',
                            help='Filtra logs por padr√£o')
    
    # Comando: status
    parser_status = subparsers.add_parser('status', help='Verifica status do Node')
    
    # Comando: send
    parser_send = subparsers.add_parser('send', help='Envia mensagem ao Sink')
    parser_send.add_argument('message', type=str, help='Mensagem a enviar')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        return 1
    
    # Executar comando
    commands = {
        'start': cmd_start,
        'interactive': cmd_interactive,
        'logs': cmd_logs,
        'status': cmd_status,
        'send': cmd_send,
    }
    
    return commands[args.command](args)

if __name__ == '__main__':
    sys.exit(main())
